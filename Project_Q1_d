import matplotlib.pyplot as plt
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import scipy as sp
from matplotlib import cm

#global parameters
Length = 5
D = 1.0
C_val = 1.0                
N = 100            
#for stability alpha must be < 1/2
#alpha = D * dt / dx**2 
alpha = 0.4
tmax = 10.0

#List of parameters to scale L by
#gamma_list = [2,6,12]
gamma = 12 #Change as required


#-------------Grids for variables------------
#x_grid = np.arange(-L/2,L/2,dx)

#In the x grid, since we know the two endpoints from the boundary condition we are particularly interested in the interior points

def funcplot_gamma(L,gamma):
    dx = L / (N - 1)
    L = 1
    dt = alpha * dx**2 / D 
    nt = int(tmax / dt)
    x_grid = np.linspace(gamma*-L/2,gamma*L/2,N)
    x_interior = x_grid[1:-1]
    #Defining C and then Beta in terms of this new x grid
    C = np.zeros_like(x_grid)

    for i, x in enumerate(x_grid):
        if abs(x) <= L/2:
            C[i] = C_val
        else:
            C[i] = 0

    beta = 1 + C*dt

    
    t_grid = np.linspace(0,tmax,nt)
    #--------------------------------------------

    u = np.zeros_like(x_grid)
    center = (N-1)//2 #rounds down - arbitrary choice though
    u[center] = 1/dx

    snapshot_gap = max(1,nt//400) #don't want to overcrowd plot

    #-------looping through time to evolve it

    u_storage = []
    t_storage=[]
    for n in range(nt):
        updated_u = u.copy()
        for i in range(1,N-1): #ONLY WANT TO UPDATE INTERIOR POINTS SINCE BOUNDARY CONDITIONS ARE FIXED AT 0
            updated_u[i] = alpha*(u[i+1] - 2.0*u[i] + u[i-1]) + beta[i]*u[i] #beta is an array so take ith beta (dependent on C) probably not the cleanest way to do all this :/
        u = updated_u


        #plotting in 2D
        #if n % snapshot_gap==0: #Doing this because it's super cluttered otherwise - comment out after to see full plot
        #   plt.plot(x_grid,u)

        #for the purpose of plotting in 3D
        if n% snapshot_gap ==0:
            u_storage.append(u.copy())
            t_storage.append(n*dt)
    t_storage = np.array(t_storage)
    u_storage=np.array(u_storage)

    #color map
    x,t = np.meshgrid(x_grid,t_storage)

    fig, ax = plt.subplots(subplot_kw={"projection": "3d"})

    #surface plot
    surf = ax.plot_surface(x, t, u_storage, cmap=cm.plasma,
                        linewidth=0, antialiased=False)

    #adds the gradient (probably a better way to do this but whatever)
    #fig.colorbar(surf, shrink=0) #shrink = 0 removes the colorbar entirely
    plt.show()
#-----------------------------------------------------------------
#FINDING CRITICAL LENGTH BELOW
#-------------------------------------------------------------------

#Want to plot a way to see if we are above/below critical length
#Will use a simple sum of u(x,t) for a range of L and plot it against time
L_array = np.linspace(0.1,1,15) #Change the first two numbers as desired to hone in on L_c approximation 

#THIS IS BUGGED FOR SURE - CHANGES A LOT WHEN I CHANGE THE VARIABLE L AT THE TOP - IT SHOULD ONLY DEPEND
#ON VALUES INSIDE L_array
def critical_finder(L_array, gamma):

    curves = []
 
    for L in  L_array:
        #Rebuilding x grid to use each L here (Certain parameters are being redefined inside of the function as the global parameters don't correspond 
        #to the L value contained in the L array otherwise)
        x_grid = np.linspace(gamma * -L/2, gamma * L/2, N)
        dx = x_grid[1] - x_grid[0]
        dt = alpha * dx**2 / D 
        nt = int(tmax / dt)
        t_grid = np.linspace(0,tmax,nt)
        #below is same as before


        C = np.zeros_like(x_grid)

        for i, x in enumerate(x_grid):
            if abs(x) <= L/2:
                C[i] = C_val
            else:
                C[i] = 0
        beta = 1 + C*dt

        #resetting u list 
        u = np.zeros_like(x_grid)
        u[(N-1)//2] = 1/dx

        #array to store totals
        sumvtime = []

        for n in range(nt): 
            updated_u = u.copy()
            updated_u[1:-1] = (alpha * (u[2:] - 2*u[1:-1] + u[:-2])+ beta[1:-1] * u[1:-1]) #Faster numpy slicing since this step was super slow when done multiple times...

            u = updated_u
            total = np.sum(u)*dx #If grid size changes this is more stable also better approximates an integral with the dx being there
            sumvtime.append(total)
        
        curves.append((t_grid,sumvtime))
        
    for i, (tvals, sumcurve) in  enumerate(curves):
        plt.semilogy(tvals, sumcurve, label=f"L={L_array[i]:.2f}")
        #plt.plot(tvals, sumcurve, label=f"L={L_array[i]:.2f}")
    plt.xlabel("t")
    plt.ylabel("Sum of u")
    plt.title(f"Sum of u=(x,t) Against Time at Various L for gamma = {gamma}")
    plt.legend()
    plt.show()


#Calling functions

critical_finder(L_array,gamma)

funcplot_gamma(Length,gamma)




